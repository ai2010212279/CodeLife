1.事务隔离级别有哪些

```
未提交读，read uncommitted；会造成脏读
提交读，read committed；会造成不可重复读
可重复读，repeatable reads；仍会造成幻读
序列化，serializable；没有任何问题，但是操作比较慢
```

原文：[http://www.hollischuang.com/archives/943](http://www.hollischuang.com/archives/943)

2.全局事务/分布式事务的原理是什么

两段事务提交

第一阶段，准备阶段。

```
1.事务管理器向所有事务参与者询问是否可以执行提交操作，并等待参与者返回响应

2.参与执行问题发起未知的所有事务操作，并将undo和redo信息写入日志。（此时参与者已经执行了该事务）

3.各参与者响应事务管理器节点发起的信息。事务执行成功，则返回“成功”；失败则返回“失败”
```

第二阶段，提交阶段

```
如果事务管理器收到参与者的失败信息或者超时，直接给每个参与者发送rollback信息；扶着发送commit信息。参与者根据指令执行提交或者回滚操作，释放事务过程中使用的锁资源。
```

两段提交的问题：

```
1.同步阻塞。

2.单点故障。事务管理器是单点

3.数据不一致。提交阶段完成后，可能会由于网络等问题导致参与者无法获取到事务管理器发送的消息，导致事务被回滚导致数据不一致。
```

两段提交的改进版-&gt;三段提交。三段提交也是有缺陷的。

世上只有一种一致性算法，那 即时Paxos。所有其他的一致性算法都是Paxos的不完整版。

[http://www.hollischuang.com/archives/681](http://www.hollischuang.com/archives/681)

3.事务是什么

事务通常指数据库事务，他是指访问并可能更新数据库中各种数据项的一个程序操作单元。他需要满足四种特性，通常称为ACID：

```
1.原子性，atomicity
2.一致性，consistency
3.隔离性，isolation
4.持久性，duration
```

4.乐观锁，悲观锁

```
乐观锁是指，在更新数据的时候，假设没有人跟自己进行竞争，在真正更新数据的时候才去检查数据是否有变更。
如果数据没有变更则更新数据，如果数据有变更则或取新的数据，重新进行更新操作。
在实现上，一般在数据库中使用一个版本号的字段作为乐观锁
```

```
悲观锁是指，在更新数据的时候，假设有人跟自己进行竞争，所以先上锁，再对数据进行更新操作。
实现上一般是在sql后面加上for update
```

5.聚集索引和非聚集索引的区别

聚集索引：索引的逻辑顺序决定了数据的物理顺序

非聚集索引：索引和数据分开存储。索引顺序与数据的物理顺序不一致

InnoDB：使用聚集索引，因此必须设置一个默认的主键。在InnoDB中，主键索引使用的是聚集索引，非主键索引的data域会指向主键索引的key域。所以，在InnoDB中，使用非主键索引查询的时候会进行两次查询。第一次查找是根据索引找到主键索引，第二次查找是根据主键索引查找到最终的data

MyISBM：使用非聚集索引。

6.表关联时，左连接，右连接，内连接怎么理解

```
内连接：仅显示匹配的数据
左连接：以左边数据为基准，与右边的数据进行连接。如果右边数据缺失，则用null代替
右连接：以右边数据为基准，与左边的数据进行连接。如果左边数据缺失，则用null代替
全连接：完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。
如果表之间有匹配行，则整个结果集行包含基表的数据值。
交叉连接：交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。
```

[http://www.cnblogs.com/zxlovenet/p/4005256.html](http://www.cnblogs.com/zxlovenet/p/4005256.html)

7.什么是参数化查询？

```
使用参数化查询时，数据库会将sql语句进行预编译，同时参数部分用问号(?)代替。在正式执行sql的时候，用户只能提供的所有参数都只是查询需要的
数据。数据库不会将数据当成sql指令的一部分进行执行。因此避免的sql注入。
sql注入即查询的参数中携带了破坏性指令，从而导致了sql指令编译发生变化。
```



